import { type NextRequest, type NextContext, NextResponse, objectify, withValidation } from "@meta-ultra/app-router";
import { isEqual, isArray, isString } from "lodash-es";
import * as yup from "yup";
/* Dexie START */
import { query } from "@meta-ultra/dexie-utilities";
import { db, I{{~upperCamelCase entityName~}}TableName, I{{upperCamelCase entityName}}{{#unless (isNilorEmpty foreigns many)}}, {{upperCamelCase entityName}}{{/unless}} } from "{{databasePackage}}";
/* Dexie END */

const $table = db[I{{~upperCamelCase entityName~}}TableName];

const searchParamsSchemaOfGet = yup.object({
  page: yup.number().integer().min(1),
  pageSize: yup.number().integer().min(1),
  sorter: yup.object({
    field: yup.string(),
    order: yup.string(),
  }),
  {{!-- {{#unless (isNilorEmpty (getPrimaryField fields))}}
  {{#with (getPrimaryField fields)}}
  {{this.[0]}}s: yup.array().of(yup.{{frameYupSchema this.[1]}}),
  {{/with}}
  {{/unless}} --}}
  {{#each fields}}
  {{this.[0]~}}: yup.{{~frameYupSchema this.[1]~}},
  {{/each}}
});
export const GET = withValidation(
  { searchParamsSchema: searchParamsSchemaOfGet },
  async function (request: NextRequest, context: NextContext) {
    try {
      const { page, pageSize, sorter, ...rest } = searchParamsSchemaOfGet.cast(objectify(request.nextUrl.searchParams));
      /* Dexie START */
      const { total, data } = await query($table, rest, page, pageSize, sorter);
      {{#unless (isNilorEmpty foreigns many)}}

      await Promise.all(
        data.map(async (record: {{upperCamelCase entityName}}) => {
          return Promise.all([
            {{#each foreigns}}
            await record.load{{~upperCamelCase (nameForignField this.[0] this.[1].fieldName)~}}(),
            {{/each}}
            {{#each many}}
            await record.load{{~upperCamelCase (pluralizeLowerCamelCase this.[1].entityName)~}}(),
            {{/each}}
          ])
        })
      );
      {{/unless}}
      /* Dexie END */

      return NextResponse.json({
        code: 0,
        data: {
          total,
          data,
        }
      });
    }
    catch(e) {
      return NextResponse.json({
        code: 1,
        error: e,
        message: (e as {message?: string}).message,
      });
    }
  }
);

const searchParamsSchemaOfDelete = yup.object({
  {{#unless (isNilorEmpty (getPrimaryField fields))}}
  {{#with (getPrimaryField fields)}}
  {{this.[0]}}s: yup.mixed().test((value) => yup.{{frameYupSchema this.[1]}}.isValidSync(value) || yup.array().of(yup.{{frameYupSchema this.[1]}}).isValidSync(value)),
  {{/with}}
  {{/unless}}
  {{#each fields}}
  {{this.[0]~}}: yup.{{frameYupSchema this.[1]}},
  {{/each}}
});
export const DELETE = withValidation(
  { searchParamsSchema: searchParamsSchemaOfDelete },
  async function (request: NextRequest, context: NextContext) {
    try {
      let { {{#unless (isNilorEmpty (getPrimaryField fields))}}{{#with (getPrimaryField fields)}}{{this.[0]}}s, {{/with}}{{/unless}}...rest } = searchParamsSchemaOfDelete.cast(objectify(request.nextUrl.searchParams));
      await db.transaction("rw", $table, async () => {
        {{#unless (isNilorEmpty (getPrimaryField fields))}}{{#with (getPrimaryField fields)~}}
        if (isArray({{this.[0]}}s)) {
          {{this.[0]}}s = yup.array().of(yup.{{frameYupSchema this.[1]}}).cast({{this.[0]}}s);
          await $table.bulkDelete(({{this.[0]}}s as any[]).filter((x) => x !== undefined) as {{this.[1].type}}[]);
        }
        else if (isString({{this.[0]}}s)) {
          {{this.[0]}}s = yup.{{frameYupSchema this.[1]}}.cast({{this.[0]}}s);
          await $table.bulkDelete([{{this.[0]}}s] as number[]);
        }
        else {
          const { total, data } = await query($table, rest);
          await Promise.all(data.map(async (target) => {
            return $table.filter((record: I{{upperCamelCase ../entityName}}) => {
              return isEqual(record, target);
            }).delete();
          }));
        }
        {{/with}}
        {{~else~}}
        const { total, data } = await query($table, rest);
        await Promise.all(data.map(async (target) => {
          return $table.filter((record: I{{upperCamelCase entityName}}) => {
            return isEqual(record, target);
          }).delete();
        }));
        {{/unless}}
      });
      return NextResponse.json({code: 0});
    }
    catch(e) {
      return NextResponse.json({
        code: 1,
        error: e,
        message: (e as {message?: string}).message,
      });
    }
  }
);

const bodySchemaOfPost = yup.object({
  {{#each fields}}
  {{this.[0]~}}: yup.{{frameYupSchema this.[1] true}},
  {{/each}}
});
export const POST = withValidation(
  { bodySchema: bodySchemaOfPost },
  async function (request: NextRequest, context: NextContext) {
    try {
      const data = bodySchemaOfPost.cast(await request.json());
      $table.add({...data});
      return NextResponse.json({code: 0});
    }
    catch(e) {
      return NextResponse.json({
        code: 1,
        error: e,
        message: (e as {message?: string}).message,
      });
    }
  }
);